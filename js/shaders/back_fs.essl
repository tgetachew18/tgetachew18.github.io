shaderSource[document.currentScript.src.split('js/shaders/')[1]] = `
	precision highp float;
	varying vec2 texCoord;
	varying vec3 color;
	uniform samplerCube envmapTexture;
	uniform sampler2D colorTexture;
	uniform vec3 lightPos[1];
	uniform vec3 ballVelocity;
	uniform vec3 lightPowerDensity[1];
	uniform mat4 quadrics[32];
	uniform vec4 brdfs[16];
	uniform vec4 properties[16];
	varying vec3 rayDir;
	varying vec4 eyepos;
	float BEACHBALL = 0.0;
	float ISLAND = 1.0;

	float intersectQuadric(mat4 A, vec4 e, vec4 d){
		//Coefficient matrix : A
		// Ray origin: e
		//Ray direction d

		float a = dot(d * A, d);
		float b = dot(d * A, e) + dot(e * A, d);
		float c = dot(e * A, e);
		float discriminant = b * b - 4.0*a*c;
		if (discriminant < 0.0){
			return -1.0;
		}
		float t1 = (-b - sqrt(discriminant))/(2.0*a);
		float t2 = (-b + sqrt(discriminant))/(2.0*a);
		float t = min(t1, t2);
		if (t >= 0.0){
			return t;
		}
		else{
			return max(t1, t2);
		}
		return t;



	}

	float intersectClippedQuadric(mat4 A, mat4 B, vec4 e, vec4 d){


		float a = dot(d * A, d);
		float b = dot(d * A, e) + dot(e * A, d);
		float c = dot(e * A, e);
		float discriminant = b * b - 4.0*a*c;
		if (discriminant < 0.0){
			return -1.0;
		}
		float t1 = (-b - sqrt(discriminant))/(2.0*a);
		vec4 r1 = e + d * t1;
		float r1inB = dot(r1 * B, r1);
		if (r1inB > 0.0){
			t1 = -1.0;
		}
		float t2 = (-b + sqrt(discriminant))/(2.0*a);		
		vec4 r2 = e + d * t2;
		float r2inB = dot(r2 * B, r2);
		if (r2inB > 0.0){
			t2 = -1.0;
		}

		float t = min(t1, t2);
		if (t >= 0.0){
			return t;
		}
		else{
			return max(t1, t2);
		}
		return t;



	}

	float findBestHit( vec4 e, vec4 d,out mat4 bestA, out vec4 bestBrdf, out vec4 bestProp){
		float bestT = 1000000000.0 ; //infinity
		vec4 property;
		for (int i = 0; i < 10; i+=2){
			mat4 A = quadrics[i];
			mat4 B = quadrics[i+1];
			property = properties[i/2];
			vec4 brdf = brdfs[i/2];
			float tempT = intersectClippedQuadric(A, B, e, d);
			if (tempT >= 0.0){
						bestT = min(tempT, bestT);	
						bestA = A;
						bestProp = property;
						bestBrdf = brdf;
			}
		}
		if (bestT == 1000000000.0){
			return -1.0;
		}
		return bestT;

	}

	vec4 beachBallTexture(vec4 surface, float x, float y, float z){
		vec4 final;
		vec4 r = surface - vec4(x,y,z,0.0);


		float theta = degrees(acos(-r.y/length(r)));
		float phi = degrees(atan(r.z/r.x));
		   if (phi >-90.0 && phi < -45.0 && theta > 0.0 && theta < 180.0){
				final = vec4(1,0,0,1);		
		   }

			else if (phi >-45.0 && phi < 0.0 && theta > 0.0 && theta < 180.0){
				final = vec4(0,0,1,1);		
		   }
		   else if (phi >0.0 && phi < 45.0 && theta > 0.0 && theta < 180.0){
				final = vec4(0,1,0,1);		
		   }
		   else{
		   		final = vec4(1,1,0,1);
		   }


		return final;
	}

float rand(float n){return 2.*abs(sin(2.*fract(sin(1000.*n) * 43758.5453123)));}


	void main(void) {

		vec4 raydirection = vec4(normalize(rayDir), 0 );
		mat4 bestA;
		vec4 bestProp;
		vec4 bestBrdf;
		vec4 finalColor;
		float t = findBestHit(eyepos, raydirection, bestA, bestBrdf, bestProp);
		if (t >= 0.0){

			vec4 r = eyepos + raydirection * t; // The eye to surface ray 

			r.w = 1.0;
			vec4 n = normalize( r*bestA + bestA*r );	
			n.w = 0.0;
			if (bestProp.a == BEACHBALL){
				finalColor = beachBallTexture(r, -bestA[0][3], -bestA[1][3], -bestA[2][3]);
			}
			else{
				finalColor =  0.8*(rand(r.x)/2.)*vec4(238./255., 214./255., 175./255.,1.0) ;//+ vec4(238./255., 214./255., 175./255.,1.0);

			}

		 	for (int i = 0; i < 1; i++){ // Implements shadows
		 		vec3 lightdirection = normalize( r.xyz - lightPos[i] );
		 		vec4 dummy;
		 		float shadow_t = findBestHit( vec4(lightPos[i],1) , vec4(lightdirection, 0), bestA, dummy, dummy);
		 		if (shadow_t > 0.0){
		 				 vec3 r_shadow =  lightPos[i] + lightdirection * shadow_t;
		 				 float srctoShadow = distance(lightPos[i], r_shadow);
		 				 float srctoPoint = distance(lightPos[i], r.xyz);
		 				 if (srctoShadow + .8  <= srctoPoint){
		 				 	finalColor *= 0.4;
		 				 }
		 		}
		 	}
		    
		 //   	

		 //	Diffuse & Ambient lighting
			vec3 L = -normalize(lightPos[0] ); //light positoin
			float lambertTerm  = clamp(dot(n.xyz, -L), 0.0, 1.0);
			vec4 lDiffuse =  vec4(1,1,1,1)* finalColor * lambertTerm;
			vec4 lAmbient = 0.3 * finalColor;
			lAmbient.w= 1.0;
			lDiffuse.w = 1.0;

			//Phongblin
			vec3 eyeVec = vec3(eyepos - vec4(0,0,0,1)  );
			vec3 E = normalize(eyeVec);
			vec3 R = reflect(L, normalize(n.xyz));
			float specular = pow(max(dot(R, E), 0.0), 40.0);
			vec4 lSpecular =  vec4(1,1,1,1)* specular;


		   gl_FragColor =   lAmbient + lDiffuse + lSpecular ;
		   gl_FragColor.w = 1.;

		}

		else{
				gl_FragColor = vec4(9./255., 138./255., 149./255.,1);//textureCube(envmapTexture, rayDir);//texture2D(colorTexture, texCoord);

	}

	}
`;


